## vue 父组件异步传递 props 值，子组件接收不到

> 原因：父组件传递的值为异步获取，子组件挂载完毕后父组件才会挂载

##### 解决方式

1. 使用 v-if
2. 使用 wacth 监听
3. 使用 key

### Vue 子组件为什么不可以修改父组件传递的 Prop

> 为了保证数据的单向流动，便于对数据进行追踪，避免数据混乱

单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。一个父组件可能存在许多个子组件如果每个子组件可以修改父级传递的数据，将会导致修改数据的源头不止一处。保证数据修改源唯一。

- 如果修改了，Vue 是如何监控到属性的修改并给出警告的？
  在组件执行 initProps 方法时，会执行 defineReactive 方法。传入的第四个参数是自定义的 set 函数，该函数会在触发 props 的 set 方法时执行，当 props 修改了，就会运行这里传入的第四个参数，然后进行判断，如果不是 root 根组件，并且不是更新子组件，那么说明更新的是 props，所以会警告。

但是，源码只是进行了浅度监听，即只能监听几种基础类型，如果 Props 是个对象，在子组件修改某个 key 的值的话就不会报错了

### 观察者模式 和 订阅发布模式 的区别

**区别**：最大的区别就是订阅发布模式有一个事件调度中心。观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知。

### vue 在渲染大量数据时应该怎么优化

- 添加加载动画 loading 图等，优化用户体验
- 利用服务器渲染 SSR，在服务端渲染组件
- 避免浏览器处理大量的 dom，比如懒加载，异步渲染组件，使用分页
- 对于固定的非响应式的数据，使用 Object.freeze 冻结

### pinia 和 vuex 有什么区别，为什么要使用 pinia

- Vuex：State、Gettes、Mutations(同步)、Actions(异步)
- Pinia： State、Gettes、Actions(同步异步都支持)

**优点**：

1. Pinia 对 vue2 和 vue3 都支持,尤其是 TypeScript 的项目
2. 没有模块的嵌套结构
3. 不需要注入、导入函数、调用它们
4. 无需手动添加 store，它的模块默认情况下创建就自动注册的
5. 支持 Vue DevTools
6. 支持服务端渲染

**缺点**：
与 Vuex 相比，它没有庞大的社区支持和解决方案。
Pinia 不支持调试功能，如时间旅行和编辑。

### vue nextTick 怎么实现的

nextTick 存在的原因是 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替

**步骤**：

1. 将回调函数添加到 callbacks 中等待执行
2. 将执行函数放入到宏任务(setImediate 或者 setTimeout)或者微任务(promise,mutationObserver)中
3. 事件循环到了微任务或者宏任务，执行函数依次执行 callbacks 中的回调
