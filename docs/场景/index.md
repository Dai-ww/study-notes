### 对 axios 二次封装

1. 添加请求拦截器，添加 token、cookie、请求体加验证、设置请求头等
2. 添加响应拦截器，处理错误、返回数据、设置 token、cookie 等

### 从代码提交到上线流程（pdlc 软件发布的生命周期）

1. 从主分支新建业务开发分支，完成功能开发后提交代码
2. 创建 Pull Request（PR），经过自动化代码检查、单元测试和同事人工审核，确保代码质量。审核通过后，合并更改至主分支。
3. 合并到主分支的更改通过 Webhooks 事件自动触发持续集成流程，开始构建部署
4. 使用脚本自动化构建和打包代码。构建成功后，利用构建工具读取项目中的 Dockerfile，生成 Docker 镜像，并推送至远程镜像仓库
5. 利用云效平台的 AppStack 功能进行应用部署，持续集成。

### 如何通知用户更新了

通过获取文档，对比前后是否一致进行比较

### k8s，vm（虚拟机）区别

vm 是一种虚拟化技术。是一个单机，通过不同文件夹指向不同项目，可部署多个。
k8s 是通过 yaml 配置文件来定义应用程序的部署，更新镜像，管理容器等
核心组件
pods：基本部署单元，一个 pod 可包含一个或者多个容器
igress：管理外部访问集群内服务的规则
depolyment：管理 pod 的声明和更新，确保 pod 始终以期望的数量运行
serives：定义 pod 的逻辑和访问它们的策略，通常用于内部服务器发现和负载均衡。

### 构建项目

执行创建命令。pnpm umi create (提供参数和变量)-->通过 cli（工具箱，脚本解析，放进占位符）-->download 云模版（仓库中提前维护好的）

### 项目如何做的权限管理

基于角色的权限控制策略：
接口层：通过 axios 拦截器去做，当用户访问一个未授权的接口时，服务端返回一个 401，403 的状态码，前端会自动跳转到登录页面。
菜单层：服务端返回一个对应的权限菜单，在前端根据权限菜单渲染对应的路由。
封装递归菜单
路由层：1.直接在前端挂载全部用户可以访问的路由，通过路由守卫去控制访问权限 vue 中可以在每个路由的声明中家 meta 信息，标记当前路由的授权访问角色 react 中封装一个自己的组件和 roles 列表进行匹配，然后根据匹配结果决定是否渲染该组件。2.动态添加
组件层：封装组件或指令，具体：通过后台返回数据获取 全集权限 code

### 近期做过的一个项目

是一个基础平台，主要的功能是使⽤户能够通过单⼀⼊⼝访问公司多个项⽬，主要包括登录，企业认证，企业管理，角色管理，合同模版管理，站内信管理等基本信息管理功能。我主要负责其中登录，认证，企业审批等多个模块的开发。主要通过 qiankun 框架的子应用机制，将多个项目打包成子应用，并通过主应用进行统一管理来实现 跨项目访问。

### 项目基座 chassis

chassis：提供一些公用的组件和工具库，统一的 layout 和编码规范。

### 微前端 qiankun

微前端是一种将不同的前端应用组合到一起的架构模式，这些应用可以进行独立开发、独立部署、独立运行，然后在一个子应用中集成。
**优点**：1. 解耦，子应用可以独立开发，可以独立部署，可以独立运行。2. 技术栈无关。3. 并行开发
**挑战**：1. 一致性：设计和行为上的一致性 2.状态共享：使用特殊的工具 3. 跨域：子应用和主应用之间需要解决跨域问题
**工作原理**：通过动态创建 script 标签的方式加载子应用的 entry 入口文件，然后将其挂载在主应用的某一个 dom 下，可以挂载多个，可以使每个项目有在浏览器中有自己的运行时。
**qiankun 怎么做到隔离？**
通过一些沙箱隔离机制，比如，创建了 window 的副本（fakeWindow），并使用 Proxy 代理来拦截对 window 的访问和赋值，从而避免子应用对主应用全局状态的直接影响
**父子项目间的通信**:
官方提供：通过定义全局状态 setGobalState，并通过 onGlobalStateChange 和 offGobalStateChange 来注册和取消观察者函数，返回通信方法，微应用通过 props 获取通信方法
自己实现：1. 在全局对象 window 上定义共享的属性或方法 2.自定义事件，定义一个全局的通信对象提供两个方法，一个用来派发事件，一个用来监听事件
目前使用：@umi/max 内置了 Qiankun 微前端插件，当使用数据流插件时，它允许微应用通过 useModel('@@qiankunStateFromMaster') 方法获取父应用传递给子应用的数据 Model，进而实现父子应用间的通信。

### 项目的难点和亮点

亮点： 我们利用 qiankun 拆分的微前端，按功能拆分系统，独立开发、部署、维护。
各个系统的公共部分，例如：通用方法、组件、eslint/prettierrc 配置，都由 chassis 包统一管理，能确保所有项目的标准都是统一的。
与后端一起做约定的标准化接口，利用 node 脚本解析 swagger-json 自动生成 api 方法。
难点：vue 中有些函数，react 没有对应的 hooks，写自定义 hooks，对 react 的了程度

### uniapp

使用 vue.js 开发所有前端应用的框架，编写一套代码可以发布到多个平台。uni-app 就是用着 vue 的指令和小程序的组件和 API
**与其他跨平台框架的区别**
技术栈：vue，性能：原生渲染技术
**原理**
将 vuejs 的模版语法转换为各个平台所支持的原生组件，再通过引擎的渲染器渲染到各个平台上。uni-app 分编译器和运行时（runtime），实现一套代码，多端运行主要是这两部分配合完成的 编译器将开发者的代码进行编译，编译的输出物由每个平台各自的 runtime 进行解析
**如何实现跨平台开发**
通过 uniapp 提供的各平台的 api 和配置文件实现跨平台开发。例如，在编写页面事，通过 uniapp 提供的原生组件（view，text）代替 html 标签。
可以通过调用 Uniapp 提供的 API 获取到原生组件进行调用。
**封装接口请求**
需要注意网络请求的跨域问题，以及请求的参数的格式。，可以在 vue.config.js 中配置代理解决跨域问题。通过 uni.request 请求接口。
**如何自定义组件**
可通过 Vue.js 的组件机制实现自定义组件。具体实现方式是，编写组件的基本结构和属性方法等，并将组件注册到 Vue.js 的全局组件或局部组件中，然后在需要使用组件的地方进行调用。
**如何使用 vuex**
在应用程序的入口文件中，注入 vuex 实例，并在其中编写状态管理器，然后在各组件中使用 mapState、mapActions 等辅助函数来访问和修改全局状态
**如何实现动态路由**
在路由配置中，使用动态路由参数来匹配不同的路由规则。例如：/user/:id
**本地缓存**
uniapp 中，可以通过 uni.setStorageSync 和 uni.getStorageSync 来设置和获取本地缓存。
**生命周期**

1. 应用 onLanuch（初始化完成时触发）-》onShow（页面显示时触发）-》onHide（页面隐藏时触发）-》onError（报错时触发）
2. 页面 onLoad（页面加载时触发）-》onShow（页面显示时触发）-》onReady（页面初次渲染完成时触发）-》onHide（监听页面隐藏）-》onUnload（页面卸载时触发）
3. 组件 beforeCreate-》created-》beforeMount-》mounted-》beforeDestroy-》destroyed

### restful 接口规范有哪些

核心原理是：使用简单的、无状态的 、基于资源的操作，是的 web 服务更加灵活，易于扩展和维护

1. 统一资源定位符
2. 使用 http 动词 GET POST PUT DELETE 等
3. 状态码 标准状态码 200 404 500 等
4. 响应数据格式 json

### 写过哪些公共组件，自定义 hooks

- 组件：

1. 表格组件：规范公司内部使用方法和统一样式，实现了一些快捷操作就和 ant 的 procomponents 一样。
2. 表单组件：方便输出一个表单状态库，可以对这个状态库进行快速的填充、重置等操作，还可以快捷生成 rule，方便表单验证。
3. 下拉选择组件：解决回显时，找不到对应选项的问题。 在 antd select 上的二次封装支持显示当前选择的数据和下拉列表，支持远程搜索，数据转换和 Props 透传。
4. 附件列表：统一的文件上传组件，通过对应业务 id 生成需要上传的文件列表
5. pdf 阅读：封装了 pdf 阅读组件，支持 pdf 预览、下载等功能。
6. 压缩按钮：列表按钮超出多少个后显示省略
   **封装组件数据怎么传输，事件如何传递，封装组件遇到过哪些问题如何解决的**
7. 组件数据如何传递：通过 props 传递，父组件向子组件传递数据，子组件通过 props 接收。
8. 事件如何传递：通过 $emit 传递，子组件通过 $emit 触发父组件的事件。
   **二次封装组件的时候，原组件有很多属性，你会一一枚举出来吗，vue2、vue3、react 分别怎么做**

- hooks

1. 表格单项提取：useProject 某一列单独抽出来，配置基本的属性，然后导出组合好的 filedProps、search 回调、数据的结果集，列配置。
2. 字典解析：useDictTransform 用于转换对象为字典格式
3. 格式化金额：usePrice

正向代理和反向代理有什么区别

1. 正向代理：客户端通过代理服务器访问互联网，代理服务器负责转发请求，并获取响应，然后将响应返回给客户端。客户端 → 正向代理服务器 → 目标服务器
   适用场景：1.客户端需要访问互联网，但出于安全考虑，不允许直接访问。2.需要对客户端的请求进行监控、过滤或修改。3.需要对客户端进行负载均衡。
2. 反向代理：反向代理服务器接收客户端的请求，并将请求转发给后端的服务器，然后获取响应，并将响应返回给客户端。客户端 → 反向代理服务器 → 后端服务器
   适用场景：1.需要隐藏后端服务器的详细信息，提高安全性。2.需要对请求进行负载均衡，分发到不同的服务器处理。3.实现网站访问统计。

### 为什么有的请求能用 get 却要使用 post

1. 数据安全性
2. 数据量大

### 三次握手和四次挥手
- 三次握手
a-b：a问b你能听到吗
b-a：b回答能听到，并反问a能不能听到
a-b：a回答b，能听到，连接确定
- 四次挥手
a-b：a和b说我先走了（停止发送数据）
b-a：b和a说那你走吧
b-a：b和a那我也走了
a-b：a和b说好的。你走吧
- 为什么握手三次挥手四次
因为只有当客户端和服务端都没有数据要发送的时候才能断开tcp
客户端第一次挥手发送FIN报文只能保证客户端没有数据要发送了，而服务端收到客户端的FIN报文后回复了一个确认报文告诉客户端我收到你的FIN报文了，但是我还有数据没发送，数据发送完后，会给客户端发送一个FIN报文，客户端确认后，关闭连接
- 为什么客户端第四次挥手需要等2msl的时间才能释放tcp连接
如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL

### websocket 消息通知场景
我们只做的消息通知，用来接消息的，前端只给后端发了 ping 做心跳用的
用 http 也行，但是要一直轮询，http 的开销要比 websocket 大，因为要一直频繁的握手挥手

### useEffect 和 useMemo 区别
useEffect用于处理副作用，即那些会改变外部环境的操作，比如数据获取、订阅或手动更改DOM。
useMemo用于记忆计算结果，避免在每次渲染时都进行相同的计算。
- 什么时候使用useCallback和useMem
如果该函数或变量作为 props 传给子组件，请一定要用，避免子组件的非必要渲染
- 为什么变量计算不在 useEffect 中进行
useEffect 在组件渲染后执行，这意味着它可能会延迟计算的执行。如果计算结果需要立即反映在组件的渲染中，使用 useEffect 可能会导致延迟
即使指定了依赖项，useEffect 中的代码也会在每次组件渲染后执行

### 父子通信为什么使用 props 更好
props提供了明确的数据流向，使得父子组件之间的关系一目了然
相比于context，props不会导致不必要的组件重新渲染

### 如果使用 webpack 打包的项目特别大，怎么进行优化
1. 确保更新到最新版本，开启生产环境，tree shaking
2. 使用插件 比如删除没有使用的css，压缩插件等
3. 使用缓存和内容哈希，提高文件缓存命中率
4. 使用 webpack 的 externals 配置来排除第三方库

### 闭包不返回函数的函数不是闭包吗
闭包不一定要返回函数。闭包的本质是函数能够访问其外部函数作用域中的变量。无论是返回函数还是内部函数直接被调用，只要函数访问了外部函数的变量，就形成了闭包。

### webpack plugin 和 loader 的区别
Loaders 专注于处理模块的源代码，是模块转换的工具。允许你使用不同的语言（如TypeScript或 Sass）编写模块，或者将图像和字体等资源嵌入到打包文件中。
Plugins 用于在构建过程中执行更广泛的任务，可以影响最终的输出结果。如动态生成代码、优化打包文件、修改资源URL等。

### react如何做到state驱动ui视图
通过组件的状态管理和渲染机制（虚拟DOM机制）实现的，当组件的状态发生变化时，React会重新渲染组件，从而更新UI视图。
可以通过调用setState方法或者更新状态的useState钩子函数来更新状态。状态修改完成后会调用render函数，重新渲染组件，从而更新UI视图
在React中，状态更新是异步的。当你调用setState（在类组件中）或者更新状态的函数（在函数组件中使用useState钩子返回的函数）时，状态更新本身是立即执行的，但是实际的组件重新渲染和DOM的更新是异步进行的。

### 状态库的作用介绍
主要作用是帮助集中管理应用状态，确保数据的一致性和组件间的有效通信，尤其是当应用规模变大，组件数量增多时。
1. 集中式状态管理
2. 跨组件状态共享
3. 状态可预测性
4. 方便调试和开发：redux时间旅行
5. 提高代码的可维护性
使用Redux时，你需要创建一个store，定义action和reducer，并使用react-redux库的Provider将store提供给React应用。然后在组件中使用connect函数或者useSelector和useDispatch钩子来访问状态和分发action
对于小型到中型应用，或者那些有简单状态管理需求的应用，Context API可能是一个很好的替代方案


### 有什么办法可以从父组件读取子组件的信息或者调用子组件的函数
1. 使用props回调函数，可以将函数，作为props传递给子组件，然后在子组件中调用这个函数
2. 使用context API，创建一个全局状态，在父组件中定义provide提供value值，在子组件中使用useConText获取。
3. 使用ref,useImperativeHandle，使用ref时自定义暴露给父组件的实例值

### 对代码进行重构和性能优化
1. 通过依赖注入、模块化开发、组件化架构等方法实现高内聚低耦合
2. 减少不必要的渲染：使用React.memo、useMemo和useCallback来避免不必要的组件和函数重新渲染。这可以显著减少渲染次数，提高应用性能
3. 代码分割和懒加载：通过React.lazy和Suspense实现代码分割，按需加载组件，减少初始加载时间。这有助于提高应用的响应速度和用户体验
4. 服务端渲染（SSR）：对于首屏渲染性能要求较高的应用，可以使用服务端渲染技术，提升首屏加载速度

### http缓存
当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。
http缓存分为强缓存和协商缓存
强缓存：不会向服务器发送请求，直接从本地缓存中读取文件。如果缓存时间过期或者用户强制刷新的话则会跳过强缓存进入协商缓存。
协商缓存：会向服务器发送请求的，服务器会根据请求头的一些参数（Etag/Last-Modify）来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的请求头通知浏览器从缓存中读取资源。
如何判断是否命中：修改文件前后的hash值或者修改时间来判断是否命中。
